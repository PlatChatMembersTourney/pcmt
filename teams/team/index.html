<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../style.css">
    <link rel="icon" href="../../icons/PCMT Logo.png">
    <title>PCMT - Team</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
    <div id="header-bar">
        <div class="header-inner">
        <div class="header-content" id="link-title">
            <a href="../../">
                <img src="../../icons/PCMT Logo.png" alt="PCMT Logo" id="pcmt-logo">
            </a>
            <p>Plat Chat Members Tournament</p>
        </div>
        <nav class="header-content">
            <a class="header-link" href="../../">Home</a>
            <a class="header-link" href="../../matches/">Matches</a>
            <a class="header-link" href="../../Standings/">Standings</a>
            <a class="header-link active" href="../../teams/">Teams</a>
            <a class="header-link" href="../../stats/">Stats</a>
            <div class="header-buffer"></div>
        </nav>
        </div>
    </div>

    <div class="page-container">
    <div id="team-detail">
        <div class="stats-loading">Loading team...</div>
    </div>

    <script>
        const params = new URLSearchParams(window.location.search);
        const teamAbbr = params.get('team');
        const season = parseInt(params.get('season')) || 2;
        let currentTeam = null;
        let allTeams = {};  // CHANGE 1: added
        const cache = {};

        // CHANGE 1b: added helper
        function oppLogoFor(abbr) {
            if (!abbr || !allTeams[abbr]) return '';
            const logo = allTeams[abbr].logo.replace(/^(\.\.\/)+/, '');
            return `<img src="../../${logo}" alt="${abbr}" class="td-opp-logo" onerror="this.style.display='none'">`;
        }

        async function loadTeam() {
            const container = document.getElementById('team-detail');
            if (!teamAbbr) { container.innerHTML = '<p class="stats-error">No team specified.</p>'; return; }

            try {
                const res = await fetch(`../../data/s${season}/teams.json`);
                const teams = await res.json();
                allTeams = teams;  // CHANGE 2: added
                const team = teams[teamAbbr];
                if (!team) { container.innerHTML = `<p class="stats-error">Team "${teamAbbr}" not found.</p>`; return; }

                currentTeam = team;
                document.title = `PCMT - ${team.name}`;
                const sortedPlayers = [...team.players].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

                let html = '';
                html += '<div class="td-header">';
                html += `<img src="${team.logo}" alt="${team.name}" class="td-logo" onerror="this.style.display='none'">`;
                html += '<div class="td-header-text">';
                html += `<h1 class="td-name">${team.name}</h1>`;
                html += `<span class="td-meta">${team.abbr} · Season ${season}</span>`;
                html += '</div></div>';

                html += '<div class="td-section"><h2 class="td-subtitle">Roster</h2><div class="td-roster">';
                sortedPlayers.forEach(p => { html += `<div class="td-roster-player">${p}</div>`; });
                html += '</div></div>';

                html += '<div class="td-columns">';
                html += '<div class="td-col-left">';
                html += '<h2 class="td-subtitle">Player Stats</h2>';
                html += '<div class="td-stats-box">';
                if (season === 2) {
                    html += '<div class="stats-sub-tabs" id="td-stats-tabs">';
                    html += '<button class="stats-sub-btn active" onclick="switchStatSource(\'Angus\')">Angus</button>';
                    html += '<button class="stats-sub-btn" onclick="switchStatSource(\'pi\')">pi</button>';
                    html += '<button class="stats-sub-btn" onclick="switchStatSource(\'toxic\')">toxic</button>';
                    html += '</div>';
                }
                html += '<div id="td-stats-area"><div class="stats-loading">Loading stats...</div></div>';
                html += '<a href="../../stats/" class="td-see-all">See all stats →</a>';
                html += '</div></div>';

                html += '<div class="td-col-right">';
                html += '<h2 class="td-subtitle">Matches</h2>';
                html += '<div class="td-matches-box">';
                html += '<div class="stats-sub-tabs" id="td-match-tabs">';
                html += '<button class="stats-sub-btn active" onclick="switchMatchTab(\'upcoming\')">Upcoming</button>';
                html += '<button class="stats-sub-btn" onclick="switchMatchTab(\'completed\')">Completed</button>';
                html += '</div>';
                html += '<div id="td-matches-area"><div class="stats-loading">Loading matches...</div></div>';
                html += '</div></div>';
                html += '</div>';

                html += '<div class="td-section"><h2 class="td-subtitle">Map Stats</h2>';
                html += '<div id="td-map-area"><div class="stats-loading">Loading stats...</div></div></div>';

                container.innerHTML = html;
                loadRatingStats(team, season === 2 ? 'Angus' : 'toxic');
                loadMapStats(team);
                loadTeamMatches();
            } catch (err) {
                container.innerHTML = '<p class="stats-error">Failed to load team data.</p>';
            }
        }

        function switchStatSource(source) {
            const buttons = document.querySelectorAll('#td-stats-tabs .stats-sub-btn');
            const sources = ['Angus', 'pi', 'toxic'];
            buttons.forEach((btn, i) => btn.classList.toggle('active', sources[i] === source));
            if (currentTeam) loadRatingStats(currentTeam, source);
        }

        // ========== MATCH LOADING ==========

        let matchData = null;
        let currentMatchTab = 'upcoming';

        function switchMatchTab(tab) {
            currentMatchTab = tab;
            const buttons = document.querySelectorAll('#td-match-tabs .stats-sub-btn');
            const tabs = ['upcoming', 'completed'];
            buttons.forEach((btn, i) => btn.classList.toggle('active', tabs[i] === tab));
            renderTeamMatches();
        }

        async function loadTeamMatches() {
            try {
                const res = await fetch(`../../data/s${season}/matches/matches.json`);
                if (!res.ok) {
                    document.getElementById('td-matches-area').innerHTML = '<p class="td-no-matches">No upcoming matches</p>';
                    return;
                }
                matchData = await res.json();
                renderTeamMatches();
            } catch (err) {
                document.getElementById('td-matches-area').innerHTML = '<p class="td-no-matches">No upcoming matches</p>';
            }
        }

        function renderTeamMatches() {
            const area = document.getElementById('td-matches-area');
            if (!area) return;
            if (!matchData || !currentTeam) {
                area.innerHTML = '<p class="td-no-matches">No match data available</p>';
                return;
            }

            const teamMatches = matchData.filter(m =>
                m.team1 === currentTeam.abbr || m.team2 === currentTeam.abbr ||
                m.team1Name === currentTeam.name || m.team2Name === currentTeam.name
            );

            const filtered = currentMatchTab === 'completed'
                ? teamMatches.filter(m => m.completed)
                : teamMatches.filter(m => !m.completed);

            if (filtered.length === 0) {
                area.innerHTML = `<p class="td-no-matches">No ${currentMatchTab} matches</p>`;
                return;
            }

            const sorted = [...filtered].sort((a, b) => {
                const da = new Date(a.date || 0), db = new Date(b.date || 0);
                return currentMatchTab === 'completed' ? db - da : da - db;
            });

            // CHANGE 3: new card rendering with opponent logo + centered score
            let html = '';
            sorted.forEach(match => {
                const isTeam1 = match.team1 === currentTeam.abbr || match.team1Name === currentTeam.name;
                const oppAbbr = isTeam1 ? match.team2 : match.team1;
                const oppName = isTeam1 ? match.team2Name : match.team1Name;
                const myScore = isTeam1 ? match.score1 : match.score2;
                const oppScore = isTeam1 ? match.score2 : match.score1;
                const won = myScore > oppScore;

                html += `<a class="td-match-card" href="../../matches/match.html?id=${match.id}&season=${season}">`;
                html += `<div class="td-match-meta">${match.stage || ''}${match.date ? ' \u00b7 ' + match.date : ''}</div>`;

                if (match.completed) {
                    html += '<div class="td-match-row">';
                    html += `<div class="td-match-team td-match-team-left ${won ? 'td-match-winner' : ''}">`;
                    html += `<span class="td-match-name">${currentTeam.name}</span>`;
                    html += `<span class="td-match-abbr">${currentTeam.abbr}</span>`;
                    html += '</div>';
                    html += '<div class="td-match-center">';
                    html += `<span class="td-score ${won ? 'td-score-win' : 'td-score-loss'}">${myScore}</span>`;
                    html += '<span class="td-score-sep">:</span>';
                    html += `<span class="td-score ${!won ? 'td-score-win' : 'td-score-loss'}">${oppScore}</span>`;
                    html += '</div>';
                    html += `<div class="td-match-team td-match-team-right ${!won ? 'td-match-winner' : ''}">`;
                    html += oppLogoFor(oppAbbr);
                    html += `<span class="td-match-abbr">${oppAbbr}</span>`;
                    html += `<span class="td-match-name">${oppName}</span>`;
                    html += '</div>';
                    html += '</div>';

                    if (match.maps && match.maps.length > 0) {
                        html += '<div class="td-match-maps">';
                        match.maps.forEach(map => {
                            const ms1 = isTeam1 ? map.score1 : map.score2;
                            const ms2 = isTeam1 ? map.score2 : map.score1;
                            const mw = ms1 > ms2;
                            html += '<div class="td-map-pill">';
                            html += `<span class="td-map-pill-name">${map.name}</span>`;
                            html += `<span class="${mw ? 'td-map-win' : 'td-map-loss'}">${ms1}</span>`;
                            html += '<span class="td-map-sep">-</span>';
                            html += `<span class="${!mw ? 'td-map-win' : 'td-map-loss'}">${ms2}</span>`;
                            html += '</div>';
                        });
                        html += '</div>';
                    }
                } else {
                    html += '<div class="td-match-row">';
                    html += '<div class="td-match-team td-match-team-left">';
                    html += `<span class="td-match-name">${currentTeam.name}</span>`;
                    html += `<span class="td-match-abbr">${currentTeam.abbr}</span>`;
                    html += '</div>';
                    html += '<div class="td-match-center"><span class="td-match-vs">vs</span></div>';
                    html += '<div class="td-match-team td-match-team-right">';
                    html += oppLogoFor(oppAbbr);
                    html += `<span class="td-match-abbr">${oppAbbr}</span>`;
                    html += `<span class="td-match-name">${oppName}</span>`;
                    html += '</div>';
                    html += '</div>';
                }

                html += '</a>';
            });

            area.innerHTML = html;
        }

        // ========== DATA LOADING ==========

        function findCol(headers, names) {
            return headers.findIndex(h => {
                if (!h) return false;
                const lower = h.trim().toLowerCase();
                return names.some(n => lower === n);
            });
        }

        function filterTeamRows(rows, headers, team) {
            const teamCol = findCol(headers, ['team']);
            const rosterUpper = team.players.map(p => p.toUpperCase());

            if (teamCol !== -1) {
                const byTeam = rows.filter(r => {
                    const val = String(r[teamCol] || '').trim().toUpperCase();
                    return val === team.abbr.toUpperCase() || val === team.name.toUpperCase();
                });
                if (byTeam.length > 0) return byTeam;
            }

            for (let col = 0; col < headers.length; col++) {
                if (col === teamCol) continue;
                const byCol = rows.filter(r => rosterUpper.includes(String(r[col] || '').trim().toUpperCase()));
                if (byCol.length >= 2) return byCol;
            }
            return [];
        }

        async function getDataset(source) {
            const key = `dataset-${source}-s${season}`;
            if (cache[key]) return cache[key];

            let headers, rows;

            try {
                if (source === 'toxic') {
                    const response = await fetch(`../../data/s${season}/Player Stats.xlsx`);
                    if (!response.ok) return { headers: [], rows: [] };
                    const ab = await response.arrayBuffer();
                    const wb = XLSX.read(ab, { type: 'array' });
                    const sheet = wb.Sheets['Overall'];
                    const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                    headers = data[0];
                    rows = data.slice(1).filter(r => r[0]);
                } else if (source === 'Angus') {
                    const sheetId = '1NZNABsU_XUlmcSgjhv94KVvbRtpYji6yPjs0g2Ro3Ak';
                    const gid = '821526300';
                    const response = await fetch(`https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=${gid}`);
                    if (!response.ok) return { headers: [], rows: [] };
                    const lines = parseCSV(await response.text());
                    headers = lines[0];
                    rows = lines.slice(1).filter(r => r[0] || r[1]);
                } else if (source === 'pi') {
                    const sheetId = '1QkBIqtPC5jP1b1rKkn39U7z5DJJ-6SYdbWcgA6Wz7AQ';
                    const gid = '1023990137';
                    const response = await fetch(`https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=${gid}`);
                    if (!response.ok) return { headers: [], rows: [] };
                    const lines = parseCSV(await response.text());
                    headers = lines[1];
                    rows = lines.slice(2).filter(r => r[1] || r[2]);
                }
            } catch (err) {
                return { headers: [], rows: [] };
            }

            cache[key] = { headers, rows };
            return { headers, rows };
        }

        async function loadRatingStats(team, source) {
            const area = document.getElementById('td-stats-area');
            try {
                const { headers, rows } = await getDataset(source);
                if (!headers || headers.length === 0) { area.innerHTML = '<p class="stats-error">Data not found.</p>'; return; }

                const teamRows = filterTeamRows(rows, headers, team);
                if (teamRows.length === 0) { area.innerHTML = '<p class="stats-error">Data not found.</p>'; return; }

                const ratingCol = findCol(headers, ['r1.0', 'r', 'rating', 'rrating']);
                const playerCol = findCol(headers, ['player', 'name', 'ign']);
                if (ratingCol === -1) { area.innerHTML = '<p class="stats-error">Data not found.</p>'; return; }

                const nameCol = playerCol !== -1 ? playerCol : 0;
                const sorted = [...teamRows].sort((a, b) => (parseFloat(b[ratingCol]) || 0) - (parseFloat(a[ratingCol]) || 0));

                let html = '<table class="stats-table td-rating-table"><thead><tr><th>Player</th><th>Rating</th></tr></thead><tbody>';
                sorted.forEach(row => {
                    const name = row[nameCol] || '';
                    const rating = row[ratingCol] != null && row[ratingCol] !== '' ? parseFloat(row[ratingCol]).toFixed(2) : '-';
                    html += `<tr><td>${name}</td><td>${rating}</td></tr>`;
                });
                html += '</tbody></table>';
                area.innerHTML = html;
            } catch (err) {
                area.innerHTML = '<p class="stats-error">Failed to load stats.</p>';
            }
        }

        function parseCSV(csvText) {
            return csvText.split('\n').map(line => {
                const cells = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        cells.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                cells.push(current.trim());
                return cells;
            }).filter(row => row.some(cell => cell !== ''));
        }

        // --- map stats ---

        async function loadMapStats(team) {
            const area = document.getElementById('td-map-area');
            try {
                const path = `../../data/s${season}/Team Map Stats.xlsx`;
                const mapCacheKey = `teammap-xlsx-s${season}`;
                let ab;
                if (cache[mapCacheKey]) {
                    ab = cache[mapCacheKey];
                } else {
                    const response = await fetch(path);
                    if (!response.ok) { area.innerHTML = '<p class="stats-error">Map stats not available.</p>'; return; }
                    ab = await response.arrayBuffer();
                    cache[mapCacheKey] = ab;
                }
                const wb = XLSX.read(ab, { type: 'array' });

                const sheetName = wb.SheetNames.find(s =>
                    s === team.name || s.includes(team.abbr) || s.includes(team.name)
                );
                if (!sheetName) { area.innerHTML = '<p class="stats-error">Data not found.</p>'; return; }

                const ws = wb.Sheets[sheetName];
                const data = XLSX.utils.sheet_to_json(ws, { header: 1 });

                const headerRow = data[1] || [];
                const hasPick = headerRow.some(h => h && String(h).trim() === 'Pick');
                const leftCols = hasPick ? 10 : 9;
                const rightStart = hasPick ? 11 : 10;
                const rightEnd = hasPick ? 21 : 19;
                const overallValCol = hasPick ? 2 : 1;

                const mapHeaders = hasPick
                    ? ['Map', 'Pick', 'Ban', 'Played', 'Won', 'Win%', 'RND', 'RND Won', 'RND%', 'Atk%', 'Def%']
                    : ['Map', 'Ban', 'Played', 'Won', 'Win%', 'RND', 'RND Won', 'RND%', 'Atk%', 'Def%'];

                const mapRows = [];
                let overallAtk = null, overallDef = null;

                for (let i = 0; i < data.length; i++) {
                    if (data[i][0] === 'Atk%') overallAtk = data[i][overallValCol];
                    if (data[i][0] === 'Def%') overallDef = data[i][overallValCol];
                }

                for (let startRow = 0; startRow < data.length; startRow += 4) {
                    if (startRow + 2 >= data.length) break;
                    const nameRow = data[startRow];
                    const dataRow = data[startRow + 2];
                    if (nameRow[0] === 'Atk%' || nameRow[0] === 'Def%') continue;

                    if (nameRow[0]) {
                        const d = dataRow.slice(0, leftCols);
                        const rebuilt = [nameRow[0]];
                        for (let i = 0; i < d.length; i++) {
                            const hdr = mapHeaders[i + 1];
                            rebuilt.push(hdr && hdr.includes('%') ? fmtPct(d[i]) : fmtNum(d[i]));
                        }
                        mapRows.push(rebuilt);
                    }
                    if (nameRow[rightStart]) {
                        const d = dataRow.slice(rightStart, rightEnd);
                        const rebuilt = [nameRow[rightStart]];
                        for (let i = 0; i < d.length; i++) {
                            const hdr = mapHeaders[i + 1];
                            rebuilt.push(hdr && hdr.includes('%') ? fmtPct(d[i]) : fmtNum(d[i]));
                        }
                        mapRows.push(rebuilt);
                    }
                }

                const filteredRows = mapRows.filter(row => row.slice(1).some(cell => cell !== '-'));
                filteredRows.sort((a, b) => String(a[0]).localeCompare(String(b[0])));

                let html = '';
                if (overallAtk != null || overallDef != null) {
                    html += '<div class="team-overall-bar">';
                    html += '<div class="overall-stat"><span class="overall-label">Overall Atk%</span><span class="overall-value">' + fmtPct(overallAtk) + '</span></div>';
                    html += '<div class="overall-stat"><span class="overall-label">Overall Def%</span><span class="overall-value">' + fmtPct(overallDef) + '</span></div>';
                    html += '</div>';
                }
                html += renderTable(mapHeaders, filteredRows, 'td-maps');
                area.innerHTML = html;
                highlightTable('td-maps', 'team');
            } catch (err) {
                area.innerHTML = '<p class="stats-error">Failed to load map stats.</p>';
            }
        }

        // --- table rendering ---

        const sortState = {};
        const lowerIsBetter = ['d', 'dpr', 'fdpr', 'fd', 'ban'];

        function highlightTable(tableId, mode) {
            const table = document.getElementById(`table-${tableId}`);
            if (!table) return;
            const state = sortState[tableId];
            if (!state) return;
            state.highlightMode = mode;
            const headers = state.headers;
            const tbody = table.querySelector('tbody');
            const trs = tbody.querySelectorAll('tr');
            if (trs.length < 2) return;

            const skipCols = new Set();
            headers.forEach((h, i) => {
                const lower = (h || '').trim().toLowerCase();
                if (['#', 'player', 'team', 'map', 'mp'].includes(lower)) skipCols.add(i);
            });

            for (let col = 0; col < headers.length; col++) {
                if (skipCols.has(col)) continue;
                const hLower = (headers[col] || '').trim().toLowerCase();
                const invert = lowerIsBetter.includes(hLower);
                let bestVal = null, worstVal = null, bestIdx = -1, worstIdx = -1;

                trs.forEach((tr, rowIdx) => {
                    const td = tr.children[col];
                    if (!td) return;
                    let raw = td.textContent.trim();
                    if (raw === '' || raw === '-') return;
                    if (raw.endsWith('%')) raw = raw.slice(0, -1);
                    const num = parseFloat(raw);
                    if (isNaN(num)) return;

                    if (bestVal === null) {
                        bestVal = num; worstVal = num; bestIdx = rowIdx; worstIdx = rowIdx;
                    } else {
                        if (invert) {
                            if (num < bestVal) { bestVal = num; bestIdx = rowIdx; }
                            if (num > worstVal) { worstVal = num; worstIdx = rowIdx; }
                        } else {
                            if (num > bestVal) { bestVal = num; bestIdx = rowIdx; }
                            if (num < worstVal) { worstVal = num; worstIdx = rowIdx; }
                        }
                    }
                });

                if (bestIdx !== -1 && bestVal !== worstVal) {
                    const bestTd = trs[bestIdx].children[col];
                    if (bestTd) bestTd.classList.add('stat-best');
                }
                if (mode === 'team' && worstIdx !== -1 && bestVal !== worstVal) {
                    const worstTd = trs[worstIdx].children[col];
                    if (worstTd) worstTd.classList.add('stat-worst');
                }
            }
        }

        function renderTable(headers, rows, tableId) {
            let html = `<table class="stats-table" id="table-${tableId}">`;
            html += '<thead><tr>';
            headers.forEach((h, i) => {
                html += `<th class="sortable" onclick="sortTable('${tableId}', ${i})">${h} <span class="sort-arrow"></span></th>`;
            });
            html += '</tr></thead><tbody>';
            rows.forEach(row => {
                html += '<tr>';
                row.forEach(cell => html += `<td>${cell ?? ''}</td>`);
                html += '</tr>';
            });
            html += '</tbody></table>';
            sortState[tableId] = { headers, rows: [...rows], originalRows: [...rows], currentCol: -1, clicks: 0, highlightMode: null };
            return html;
        }

        function sortTable(tableId, colIndex) {
            const state = sortState[tableId];
            if (!state) return;
            if (state.currentCol === colIndex) { state.clicks++; } else { state.currentCol = colIndex; state.clicks = 1; }
            let sorted;
            if (state.clicks % 3 === 0) {
                sorted = [...state.originalRows]; state.currentCol = -1; state.clicks = 0;
            } else {
                const asc = state.clicks % 3 === 2;
                sorted = [...state.rows].sort((a, b) => {
                    let valA = a[colIndex], valB = b[colIndex];
                    if (typeof valA === 'string' && valA.endsWith('%')) valA = parseFloat(valA);
                    if (typeof valB === 'string' && valB.endsWith('%')) valB = parseFloat(valB);
                    const numA = parseFloat(valA), numB = parseFloat(valB);
                    if (!isNaN(numA) && !isNaN(numB)) return asc ? numA - numB : numB - numA;
                    return asc ? String(valA||'').localeCompare(String(valB||'')) : String(valB||'').localeCompare(String(valA||''));
                });
            }
            const table = document.getElementById(`table-${tableId}`);
            const tbody = table.querySelector('tbody');
            tbody.innerHTML = sorted.map(row => '<tr>' + row.map(cell => `<td>${cell ?? ''}</td>`).join('') + '</tr>').join('');
            const ths = table.querySelectorAll('thead tr:last-child th');
            ths.forEach((th, i) => {
                const arrow = th.querySelector('.sort-arrow');
                if (i === colIndex && state.currentCol !== -1) arrow.textContent = state.clicks % 3 === 1 ? ' ▼' : ' ▲';
                else arrow.textContent = '';
            });
            if (state.highlightMode) highlightTable(tableId, state.highlightMode);
        }

        function fmtPct(val) {
            if (val == null || val === '') return '-';
            if (typeof val === 'number') return (val * 100).toFixed(0) + '%';
            return val;
        }

        function fmtNum(val) {
            if (val == null || val === '') return '-';
            return val;
        }

        loadTeam();
    </script>
    </div>
</body>
</html>